#! /usr/bin/env python
# -*- coding: iso-8859-1 -*-

# Copyright: Krzysztof Kowalczyk
# Owner: Andrzej Ciarkowski
#
# Purpose: server component for iPedia
#
# Usage:
#   -silent : will supress most of the messages logged to stdout. TODO: in the
#             future will be replaced with -verbose flag (i.e. we'll be silent
#             by default)
#   -usepsyco : will use psyco, if available
#   -db name  : use database name
#   -listdbs  : list all available ipedia databases
#   -demon    : start in deamon mode

import sys, os, string, re, random, time, MySQLdb, _mysql_exceptions
import arsutils, iPediaDatabase

from twisted.internet import protocol, reactor
from twisted.protocols import basic

from arsutils import dumpException

try:
    import psyco
    g_fPsycoAvailable = True
except:
    print "psyco not available. You should consider using it (http://psyco.sourceforge.net/)"
    g_fPsycoAvailable = False

g_fDisableRegistrationCheck = True
g_unregisteredLookupsLimit=30
g_unregisteredLookupsDailyLimit=2    

# if True we'll print debugging info
g_fVerbose = None
g_fDumpPayload = False

# Protocol-Version is sent by a client with every request. It future-proofs our
# design (we can change the client-server protocol in newer versions but still
# support older clients using older protocols
# Value: a number representing a protocol version. By convetion we'll start at 1
#   and increase by 1 every time protocol changes
# Response: none
# Currently we only have one protocol of version 1.
protocolVersionField =   "Protocol-Version"
# Client-Info is sent by a client with every request. It's purely informational
# field that enables us to track what kinds of clients/devices are used most.
# Value: version of the client e.g. "Palm 1.0", "Smartphone 0.5" etc.
# Response: none
clientInfoField    =     "Client-Info"
# Transaction-ID is sent by the client and echoed by the server.
# Value: transaction id (arbitrary string)
# Client uses it to match server response with requests
# Response: Transaction-ID with the same value as sent by the client
transactionIdField =     "Transaction-ID"
# We use cookies to tie requests to a given client. Get-Cookie is sent by a
# client if it doesn't have a cookie assigned yet (which should only happen
# right after fresh install/re-install of the client).
# Value: (hopefully unique) device id in our encoded format
# Response: "Cookie" field with value being a string (cookie). 
getCookieField =         "Get-Cookie"
# Client sends cookie assigned by the server so that we can tie requests to
# a given client (so that we can do stats). Cookie is generated by the server
# and sent as a result of Get-Cookie.
# Server checks if a cookie has been generated on the server and returns error
# invalidCookie if it wasn't or userDisabled if cookie is ok but user is
# marked as disabled
# Value: cookie
# Response: none
cookieField =            "Cookie"
# Client uses Get-Article to request an article for a given title
# Value: term for which we want the article (e.g. "seattle")
# Response: (Article-Title, Article-Body, Format-Version) or Not-Found or Search-Results
getArticleField =        "Get-Article"
# Client uses Get-Random-Article to get a random article
# Value: none
# Response: (Article-Title, Article-Body, Format-Version)
getRandomField =         "Get-Random-Article"
# Sent by server along with Article-Body. Describes the format of Article-Body.
# Allows us to future-proof the design.
# Value: a number representing the format of article body. By convetion, starts
#   with 1 and will be increased by one every time we change the format.
#   Currently we only have one format (Format-Version is 1)
formatVersionField =     "Format-Version"
# Sent by server in response to Get-Article, Get-Random-Article. It's the
# article body text.
# Value: size of article body followed by text of article itself.
articleBodyField =       "Article-Body"
# Sent by server in response to Get-Article, Get-Random-Article. It's the
# title of the article we're sending. Note: it might be different than title
# requested by Get-Article due to redirects.
# Value: title of the article
articleTitleField =      "Article-Title"
# Server sends Reverse-Links along with Article-Body and Article-Title (as a
# response to Get-Article, Get-Random-Article). It's a '\n' separated list
# of article titles that link to a given article. The list is limited to 200
# - the limitation is implemented in the converter (without the limit we would
# send a lot of data (the biggest was around 100 kB) and more wouldn't be useful anyway.
# Value: payload, a '\n'-separated list of article titles that link to a given article.
reverseLinksField =     "Reverse-Links"
# Retruned by the server in response to Get-Article, if the article hasn't been
# found.
notFoundField =          "Not-Found"
# Error is returned by the server if there was an error.
# Value: error number
errorField =             "Error"
# Client sends Registration-Code if registration code has been entered by the
# user and confirmed as valid by Register request.
# Value: registration code
# Server checks if a reg code is valid returns error invalidRegCode if it wasn't
# or userDisabled if reg code is ok but user is marked as disabled
# Response: none
regCodeField =           "Registration-Code"
searchField =            "Search"
searchResultsField =     "Search-Results"
# Client sends Get-Article-Count to retrieve the number of articles in the database.
# Value: none
# Server response: Article-Count
getArticleCountField =   "Get-Article-Count"
# Server sends Article-Count as a response to Get-Article-Count
# Value: number of articles
articleCountField =      "Article-Count"
# Client sends Get-Database-Time to get the time when the database was last synced
# Value: none
# Response: Database-Time
getDatabaseTimeField =   "Get-Database-Time"
# Server sends Database-Time in response to Get-Database-Time
# Value: date when database was synced, in the format YYYY-MM-DD
databaseTimeField =      "Database-Time"
# Client sends Verify-Registration-Code when it wants to check if a given
# registration code is valid.
# Value: registration code
# Response: Registration-Code-Valid
# Note: this is only to allow us to implement a good registration process on
# the client and doesn't influence our authentication mechanizm. Client sends
# this after user enters reg code on registration code. If server says "reg code
# valid" then client saves it in preferences and sends with all future requests.
# If server says "reg code invalid" then client ask the user to re-enter the code
# or forgets all about it.
# Risk: an attacker can sniff the protocol, figure out the purpose of this request
#   and use it to do a brute-force attack to discover reg codes. A way to fix
#   that would be to encrypt reg code with assymetric cryptography.
#   Cryptographic hash isn't enough because attacker can dissamble the code to
#   figure out the hash function used and do the hashing himself)
verifyRegCodeField =    "Verify-Registration-Code"
# Server sends Registration-Code-Valid in response to Verify-Registration-Code
# Value: 1 - reg code was valid, 0 - reg code was not valid
regCodeValidField =     "Registration-Code-Valid"

# a dict of valid client requests. The value is a boolean saying if a given
# request has arguments (True if has, False if doesn't). We use it to verify
# validity of the request
validClientFields = {
  protocolVersionField   : True,
  clientInfoField        : True,
  transactionIdField     : True,
  cookieField            : True,
  getCookieField         : True,
  getArticleField        : True,
  getRandomField         : False,
  regCodeField           : True,
  searchField            : True,
  getArticleCountField   : False,
  getDatabaseTimeField   : False,
  verifyRegCodeField     : True
 }

DEFINITION_FORMAT_VERSION = "1"
PROTOCOL_VERSION = "1"

# this is a special reg code used for testing. Clients should never sent
# such reg code (a reg code format we use for real clients is a 12-digit number)
testValidRegCode    = "7432"
testDisabledRegCode = "2347"

class iPediaServerError:
    # return serverFailure if we encountered a problem in code execution
    # (e.g. exception has been thrown that shouldn't have). Usually it means
    # there's a bug in our code
    serverFailure = 1
    # unsupportedDevice - not used
    unsupportedDevice = 2
    # return invalidRegCode if the reg code is invalid
    invalidRegCode = 3
    # request from the client has been malformed. This applies to cases when
    # the request doesn't fit our strict format of request
    malformedRequest = 4
    # user has reached lookup limit for unregistered version 
    lookupLimitReached = 5
    # returned if request field is not known by the server as something that
    # client might send
    invalidRequest = 6
    # return unexpectedRequestArgument if a given request doesn't use arguments
    # but client has sent it
    unexpectedRequestArgument = 7
    # return requestArgumentMissing if a given request requres an argument
    # but client didn't send one
    requestArgumentMissing = 8
    # return invalidProtocolVersion if the value of protocolVersionField is
    # not something we handle
    invalidProtocolVersion = 9
    # return invalidCookie if users sends cookie that hasn't been generated
    # by the server
    invalidCookie = 10
    # return userDisabled if user is marked as disabled (based on cookie or
    # regCode client sends)
    userDisabled = 11

lineSeparator =     "\n"

# A format of a request accepted by a server is very strict:
# validClientRequest = validClientField ":" fieldValue? "\n"
# fieldValue = " " string
# validClientField = "Get-Cookie" | "Protocol-Version" etc.
# In other words:
#  - if request has no parameters, then it must be a requestField immediately
#    followed by a colon (":") and a newline ("\n")
#  - if request has parameters, then it must be a requestField immediately
#    followed by a colon (":"), space (" "), arbitrary string which is an argument and newline ("\n")
#
# This function parses the request line from the server and returns a tuple
# (field,value). If request has no parameters, value is None
# If there was an error parsing the line (it doesn't correspond to our strict
# format), field is None
def parseRequestLine(line):
    parts = line.split(":", 1)
    if 1==len(parts):
        # there was no ":" so this is invalid request
        return (None,None)
    field = parts[0]
    value = parts[1]
    if ""==value:
        # the second part is an empty line which means that this is a request
        # without an argument
        return (field, None)
    # this is a request with an argument, so it should begin with a space
    if ' '!=value[0]:
        # it doesn't begin with a space, so invalid
        return (None,None)
    value = value[1:]
    return (field,value)

def fValidDeviceInfo(deviceInfo):
    return True

# TODO: If we know for
# sure that device id was unique, we issue previously assigned cookie. This
# prevents using program indefinitely by just reinstalling it after a limit
# for unregistered version has been reached.
def fDeviceInfoUnique(deviceInfo):
    return False

def getUniqueCookie(cursor):
    randMax=2**16-1
    while True:
        cookie = ""
        for i in range(8):
            val = random.randint(0, randMax)
            hexVal = hex(val)[2:]
            cookie += hexVal
        cursor.execute("""SELECT user_id FROM users WHERE cookie='%s'""" % cookie)
        row = cursor.fetchone()
        if not row:
            break
    return cookie

# return a blob which is a '\n'-separated list of all article titles that link
# to a given article. Returns None if we don't have this information.
def getReverseLinks(db,cursor,articleTitle):
    articleTitleEscaped = db.escape_string(articleTitle)
    cursor.execute("SELECT links_to_it FROM reverse_links WHERE title='%s';" % articleTitleEscaped)
    row = cursor.fetchone()
    if row:
        return row[0]
    else:
        return None

# return a tuple (articleId,articleTitle,articleBody) for a random
# article from the datbase
def getRandomArticle(cursor):
    iterationsLeft = 10
    while True:
        cursor.execute("""SELECT min(id), max(id) FROM articles""")
        row = cursor.fetchone()
        (minId, maxId) = row[0], row[1]
        termId = random.randint(minId, maxId)
        query = """SELECT id, title, body FROM articles WHERE id=%d;""" % termId
        cursor.execute(query)
        row = cursor.fetchone()
        if row:
            return (row[0], row[1], row[2])
        iterationsLeft -= 1
        if 0 == iterationsLeft:
            return None

# return a tuple (articleId,articleTitle,articleBody) for an article with a
# given title (or None if article with such title doesn't exists)
def findArticle(db, cursor, title):
    # ifninite cycles shouldn't happen, but just in case we're limiting number of re-directs
    redirectsLeft = 10
    while True:
        titleEscaped = db.escape_string(title)
        query = """SELECT id, title, body FROM articles WHERE title='%s';""" % titleEscaped
        cursor.execute(query)
        row = cursor.fetchone()
        if row:
            return (row[0], row[1], row[2])
        query = """SELECT redirect FROM redirects WHERE title='%s';""" % titleEscaped
        cursor.execute(query)
        row = cursor.fetchone()
        if not row:
            return None
        title=row[0]
        redirectsLeft -= 1
        if 0 == redirectsLeft:
            return None

listLengthLimit = 200

# given a search term, return a list of articles matching this term.
# list can be empty (no matches)
def findFullTextMatches(db, cursor, searchTerm):
    print "Performing full text search..."
    words = searchTerm.split()
    queryStr = string.join(words, " +")
    queryStrEscaped = db.escape_string(queryStr)
    searchTermEscaped = db.escape_string(searchTerm)
    query = """SELECT id, title, match(title, body) AGAINST('%s') AS relevance FROM articles WHERE match(title, body) against('%s' in boolean mode) ORDER BY relevance DESC limit %d""" % (searchTermEscaped, queryStrEscaped, listLengthLimit)
    cursor.execute(query)
    row = cursor.fetchone()
    if not row:
        print "Performing non-boolean mode search..."
        query = """SELECT id, title, match(title, body) AGAINST('%s') AS relevance FROM articles WHERE match(title, body) against('%s') ORDER BY relevance DESC limit %d""" % (searchTermEscaped, queryStrEscaped, listLengthLimit)
        cursor.execute(query)

    titleList=[]
    while row:
        titleList.append(row[1])
        row=cursor.fetchone()
    return titleList


class iPediaProtocol(basic.LineReceiver):

    def __init__(self):
        self.delimiter='\n'

        self.dbManagement = None
        self.dbArticles = None
        self.error = 0

        # dictionary to keep values of client request fields parsed so far
        self.fields = {}

        self.userId = None
        self.fRegisteredUser = False

    # return true if current request has a given field
    def fHasField(self,field):
        assert validClientFields.has_key(field)
        if self.fields.has_key(field):
            return True
        return False

    # return value of a given field or None if:
    #  - field was no present
    #  - field had no value (no argument) (so use fHasField() to tell those cases apart)
    def getFieldValue(self,field):
        assert validClientFields.has_key(field)
        if self.fHasField(field):
            return self.fields[field]
        return None

    def setFieldValue(self,field,value):
        assert validClientFields.has_key(field)
        # shouldn't be called more than once per value
        assert not self.fHasField(field)
        self.fields[field] = value

    def getManagementDatabase(self):
        if not self.dbManagement:
            self.dbManagement=self.factory.createManagementConnection()
        return self.dbManagement

    def getArticlesDatabase(self):
        if not self.dbArticles:
            self.dbArticles=self.factory.createArticlesConnection()
        return self.dbArticles

    def outputField(self, name, value=None):
        global g_fVerbose
        if value:
            field = "%s: %s%s" % (name, value, lineSeparator)
        else:
            field = "%s:%s" % (name, lineSeparator)
        self.transport.write(field)
        if g_fVerbose:
            sys.stdout.write(field)

    def outputPayloadField(self, name, payload):
        global g_fDumpPayload
        self.outputField(name, str(len(payload)))
        self.transport.write(payload)
        self.transport.write(lineSeparator)
        if g_fDumpPayload:
            print payload

    # return client's (peer connection's) ip address as a string
    def getClientIp(self):
        peerInfo = self.transport.getPeer()
        clientIp = peerInfo.host
        return clientIp
        
    def logRequest(self):
        # TODO:
        return
        cursor = None
        try:
            db = self.getManagementDatabase()
            hasGetCookie = 0
            if self.fHasField(getCookieField):
                hasGetCookie = 1
            #cookieIdStr = 'NULL'
            #if self.cookieId:
            #    cookieIdStr = str(self.cookieId)
            regCodeToLog = ''
            if self.fHasField(regCodeField):
                regCodeToLog = self.getFieldValue(regCodeField)
            reqTerm = 'NULL'
            if self.fHasField(getArticleField):
                reqTerm = '\''+db.escape_string(self.getFieldValue(getArticleField))+'\''
            defFor = 'NULL'
            #if self.term:
            #    defFor='\''+db.escape_string(self.term)+'\''
            cursor = db.cursor()
            clientIp = self.getClientIp()
            #query=("""INSERT INTO requests (client_ip, has_get_cookie_field, cookie_id, reg_code, requested_term, error, definition_for, request_date) """
            #                            """VALUES (%d, %d, %s, %d, %s, %d, %s, now())""" % (clientIp, hasGetCookie, cookieIdStr, regCodeToLog, reqTerm, self.error, defFor))
            #cursor.execute(query)
            cursor.close()
        except _mysql_exceptions.Error, ex:
            dumpException(ex)
            if cursor:
                cursor.close()

    def finish(self):
        global g_fVerbose
        if self.error:
            self.outputField(errorField, str(self.error))
        self.transport.loseConnection()
        
        if self.dbManagement:
            self.logRequest()
            self.dbManagement.close()
            self.dbManagement=None

        if self.dbArticles:
            self.dbArticles.close()
            self.dbArticles=None

        if g_fVerbose:
            print "--------------------------------------------------------------------------------"

    # return True if regCode exists in a list of valid registration codes
    def fRegCodeExists(self,regCode):
        cursor = None
        try:
            db = self.getManagementDatabase()
            cursor = db.cursor()
            regCodeEscaped = db.escape_string(regCode)
            cursor.execute("""SELECT reg_code, disabled_p FROM reg_codes WHERE reg_code='%s'""" % regCodeEscaped)
            row = cursor.fetchone()
            cursor.close()
            if row and 'f'==row[1]:
                return True
        except _mysql_exceptions.Error, ex:
            if cursor:
                cursor.close()        
            dumpException(ex)
            self.error=iPediaServerError.serverFailure
        return False

    # Log all attempts to verify registration code. We ignore all errors from here
    def logRegCodeToVerify(self,userId,regCode,fRegCodeValid):
        reg_code_valid_p = 'f'
        if fRegCodeValid:
            reg_code_valid_p = 't'

        cursor=None
        try:
            db = self.getManagementDatabase()
            cursor = db.cursor()
            clientIpEscaped = db.escape_string(self.getClientIp())
            regCodeEscaped = db.escape_string(regCode)
            cursor.execute("""INSERT INTO verify_reg_code_log (user_id, client_ip, log_date, reg_code, reg_code_valid_p) VALUES (%d, '%s', now(), '%s', '%s');""" % (userId, clientIpEscaped,regCodeEscaped, reg_code_valid_p))
            cursor.close()
        except _mysql_exceptions.Error, ex:
            if cursor:
                cursor.close()        
            dumpException(ex)

    def outputArticle(self, title, body, reverseLinks):
        self.outputField(formatVersionField, DEFINITION_FORMAT_VERSION)
        self.outputField(articleTitleField, title)
        self.outputPayloadField(articleBodyField, body)
        if None != reverseLinks:
            self.outputPayloadField(reverseLinksField, reverseLinks)

    def preprocessArticleBody(self, body):
        # those macros are actually removed during conversion phase, so this
        # code is disabled. I'll leave it for now if we decide to revive it
        assert 0
        # perf: we could improve this by marking articles that need this conversion
        # in the database and only do this if it's marked as such. but maybe
        # the overhead of storing/retrieving this info will be bigger than code

        # perf: maybe we should ignore {{NUMBEROFARTICLES}} or replace it during conversion
        body=body.replace("{{NUMBEROFARTICLES}}", str(self.factory.articleCount))
        # speed up trick: don't do the conversion if there can't possibly anything to convert
        if -1 == body.find("{{CURRENT"):
            return body
        body=body.replace("{{CURRENTMONTH}}",       str(int(time.strftime('%m'))));
        body=body.replace("{{CURRENTMONTHNAME}}",   time.strftime('%B'))
        body=body.replace("{{CURRENTMONTHNAMEGEN}}",time.strftime("%B"))
        body=body.replace("{{CURRENTDAY}}",         str(int(time.strftime("%d"))))
        body=body.replace("{{CURRENTDAYNAME}}",     time.strftime("%A"))
        body=body.replace("{{CURRENTYEAR}}",        time.strftime("%Y"))
        body=body.replace("{{CURRENTTIME}}",        time.strftime("%X"))
        return body

    def handleGetArticleRequest(self):

        if self.fHasField(searchField) or self.fHasField(getRandomField):
            # those shouldn't be in the same request
            self.error = iPediaServerError.malformedRequest
            return False

        title = self.getFieldValue(getArticleField)
        cursor = None
        definition = None
        try:
            db = self.getArticlesDatabase()
            cursor = db.cursor()
            articleTuple = findArticle(db, cursor, title)
            if articleTuple:
                (articleId, title, body) = articleTuple
                reverseLinks = getReverseLinks(db,cursor,title)
                # self.preprocessArticleBody(body)
                self.outputArticle(title,body,reverseLinks)
            else:
                termList = findFullTextMatches(db, cursor, title)
                if 0==len(termList):
                    self.outputField(notFoundField)
                else:
                    self.outputField(articleTitleField, title)
                    self.outputPayloadField(searchResultsField, string.join(termList, "\n"))
            cursor.close()
        except _mysql_exceptions.Error, ex:
            dumpException(ex)
            if cursor:
                cursor.close()
            self.error=iPediaServerError.serverFailure
            return False
        return True
        
    def handleSearchRequest(self):

        if self.fHasField(getArticleField) or self.fHasField(getRandomField):
            # those shouldn't be in the same request
            self.error = iPediaServerError.malformedRequest
            return False

        searchTerm = self.getFieldValue(searchField)
        cursor = None
        try:
            db = self.getArticlesDatabase()
            cursor = db.cursor()
            termList = findFullTextMatches(db, cursor, searchTerm)
            if 0==len(termList):
                self.outputField(notFoundField)
            else:
                self.outputField(articleTitleField, searchTerm)
                self.outputPayloadField(searchResultsField, string.join(termList, "\n"))
            cursor.close()
        except _mysql_exceptions.Error, ex:
            dumpException(ex)
            if cursor:
                cursor.close()
            self.error=iPediaServerError.serverFailure
            return False
        return True

    def handleGetRandomRequest(self):

        if self.fHasField(getArticleField) or self.fHasField(searchField):
            # those shouldn't be in the same request
            self.error = iPediaServerError.malformedRequest
            return False

        cursor = None
        try:
            db = self.getArticlesDatabase()
            cursor = db.cursor()
            (articleId, title, body) = getRandomArticle(cursor)
            reverseLinks = getReverseLinks(db,cursor,title)
            # body = self.preprocessArticleBody(body)
            self.outputArticle(title,body,reverseLinks)
            cursor.close()
        except _mysql_exceptions.Error, ex:
            dumpException(ex)
            if cursor:
                cursor.close()
            self.error=iPediaServerError.serverFailure
            return False
        return True
        
    def fOverUnregisteredLookupsLimit(self):
        global g_unregisteredLookupsDailyLimit, g_unregisteredLookupsLimit, g_fDisableRegistrationCheck
        # TODO:
        return False
        cursor=None
        fOverLimit=False
        try:
            db=self.getManagementDatabase()
            cursor=db.cursor()
            assert None==self.userId
            query="SELECT COUNT(*) FROM requests WHERE NOT (requested_term is NULL) AND cookie_id=%d" % self.cookieId
            cursor.execute(query)
            row=cursor.fetchone()
            assert None!=row
            if row[0]>=g_unregisteredLookupsLimit:
                query="SELECT COUNT(*) FROM requests WHERE NOT (requested_term is NULL) AND cookie_id=%d AND request_date>DATE_SUB(CURDATE(), INTERVAL 1 DAY)" % self.cookieId
                cursor.execute(query)
                row=cursor.fetchone()
                assert None!=row
                if row[0]>=g_unregisteredLookupsDailyLimit:
                    self.error=iPediaServerError.lookupLimitReached
                    fOverLimit=True
            cursor.close()
        except _mysql_exceptions.Error, ex:
            dumpException(ex)
            if cursor:
                cursor.close()
            self.error=iPediaServerError.serverFailure
            fOverLimit=True
        if g_fDisableRegistrationCheck:
            fOverLimit = False
        return fOverLimit

    # handle verifyRegCodeField. If reg code is invalid append regCodeValidField
    # with value "0". If reg code is invalid, append regCodeValidField with value
    # "1" and update users table to mark this as a registration
    # Return false if there was an error that requires aborting connection
    def handleVerifyRegistrationCodeRequest(self):
        # by now we have to have it (from handling getCookieField, cookieField or regCodeField)
        assert self.userId

        # those are the only fields that can come with verifyRegCodeField
        allowedFields = [transactionIdField, clientInfoField, protocolVersionField, cookieField, getCookieField, verifyRegCodeField, getArticleCountField, getDatabaseTimeField]
        for field in self.fields.keys():
            if field not in allowedFields:
                self.error = iPediaServerError.malformedRequest
                return False

        regCode = self.getFieldValue(verifyRegCodeField)

        fRegCodeExists = self.fRegCodeExists(regCode)

        self.logRegCodeToVerify(self.userId,regCode,fRegCodeExists)

        if not fRegCodeExists:
            self.outputField(regCodeValidField, "0")
            return True

        # update users table to reflect the fact, that this user has registered
        cursor=None
        try:
            db = self.getManagementDatabase()
            cursor = db.cursor()
            regCodeEscaped = db.escape_string(regCode)

            # TODO: should we check if a given user is already registered? It's
            # possible scenario, but not making much sense
            cursor.execute("""UPDATE users SET reg_code='%s', registration_date=now() WHERE user_id=%d""" % (regCodeEscaped, self.userId))
            cursor.close()

            self.outputField(regCodeValidField, "1")
            return True
        except _mysql_exceptions.Error, ex:
            dumpException(ex)
            if cursor:
                cursor.close()
            self.error=iPediaServerError.serverFailure
            return False;
        assert 0

    # Set self.userId based on reg code given by client
    # Return false if there was a problem that requires aborting the connection
    def handleRegistrationCodeRequest(self):

        if self.fHasField(getCookieField) or self.fHasField(cookieField):
            # those shouldn't be in the same request
            self.error = iPediaServerError.malformedRequest
            return False

        regCode = self.getFieldValue(regCodeField)
        cursor = None
        try:
            db = self.getManagementDatabase()
            cursor = db.cursor()
            regCodeEscaped = db.escape_string(regCode)

            cursor.execute("SELECT user_id,disabled_p FROM users WHERE reg_code='%s';" % regCodeEscaped)
            row = cursor.fetchone()
            cursor.close()
            if row:
                if 't'==row[1]:
                    self.error = iPediaServerError.userDisabled
                    return False
                self.userId = int(row[0])
                return True
            else:
                self.error = iPediaServerError.invalidRegCode
                return False
        except _mysql_exceptions.Error, ex:
            dumpException(ex)
            if cursor:
                cursor.close()
            self.error = iPediaServerError.serverFailure
            return False
        assert 0
        return False

    # Set self.userId based on cookie given by client
    # Return false if there was a problem that requires aborting the connection
    def handleCookieRequest(self):

        if self.fHasField(getCookieField) or self.fHasField(regCodeField):
            # those shouldn't be in the same request
            self.error = iPediaServerError.malformedRequest
            return False

        cookie = self.getFieldValue(cookieField)
        cursor = None
        try:
            db = self.getManagementDatabase()
            cursor = db.cursor()
            cookieEscaped = db.escape_string(cookie)

            cursor.execute("SELECT user_id,disabled_p FROM users WHERE cookie='%s';" % cookieEscaped)
            row = cursor.fetchone()
            cursor.close()
            if row:
                if 't'==row[1]:
                    self.error = iPediaServerError.userDisabled
                    return False
                self.userId = int(row[0])
                return True
            else:
                self.error = iPediaServerError.invalidCookie
                return False
        except _mysql_exceptions.Error, ex:
            dumpException(ex)
            if cursor:
                cursor.close()
            self.error = iPediaServerError.serverFailure
            return False
        assert 0

    # Assign a cookie to the user. Try to re-use cookie based on deviceInfo
    # or create a new entry in users table. Set self.userId
    # Return false if there was a problem that requires aborting the connection
    def handleGetCookieRequest(self):
        if self.fHasField(regCodeField) or self.fHasField(cookieField):
            # those shouldn't be in the same request
            self.error = iPediaServerError.malformedRequest
            return False

        deviceInfo = self.getFieldValue(getCookieField)
        if not fValidDeviceInfo(deviceInfo):
            self.error=iPediaServerError.unsupportedDevice
            return False

        cursor=None
        try:
            db = self.getManagementDatabase()
            cursor = db.cursor()
            deviceInfoEscaped = db.escape_string(deviceInfo)

            if fDeviceInfoUnique(deviceInfo):
                cursor.execute("SELECT user_id,cookie,reg_code FROM users WHERE device_info='%s';" % deviceInfoEscaped)
                row = cursor.fetchone()
                if row:
                    self.userId = int(row[0])
                    self.outputField(cookieField, row[1])
                    # TODO: what to do if reg_code exists for this row?
                    # This can happen in the scenario:
                    #  - Get-Cookie
                    #  - register
                    #  - delete the app, re-install
                    #  - Get-Cookie - we reget the cookie
                    cursor.close()
                    return True

            # generate new entry in users table
            cookie = getUniqueCookie(cursor)
            # it's probably still possible (but very unlikely) to have a duplicate
            # cookie, in which case we'll just abort
            query = """INSERT INTO users (cookie, device_info, cookie_issue_date, reg_code, registration_date, disabled_p)
                                VALUES   ('%s',   '%s',              now(),       NULL,     NULL,              'f')""" % (cookie, deviceInfoEscaped)
            cursor.execute(query)
            self.userId=cursor.lastrowid
            cursor.close()
            self.outputField(cookieField, cookie)
            return True

        except _mysql_exceptions.Error, ex:
            dumpException(ex)
            if cursor:
                cursor.close()
            self.error=iPediaServerError.serverFailure
            return False
            
    # figure out user id and set self.userId
    # Possible cases:
    # a) we get registration code
    #     - user_id is "select user_id from users where reg_code = $reg_code"
    #     - cookie should not be present
    # b) we get cookie
    #     - user_id is "select user_id from users where cookie = $cookie", reg_code column should be empty
    #     - reg code should not be present
    # c) we have Get-Cookie request
    #     - we try to re-issue cookie based on device_info i.e. if deviceInfoUnique($deviceInfo)
    #       select cookie from users where device_info = $deviceInfo. if present go to b)
    #       if not present, we create a new entry in users table, and use the new user_id
    # return false if for any reson we failed and need to terminate
    def computeUserId(self):

        # case a)
        if self.fHasField(regCodeField):
            return self.handleRegistrationCodeRequest()

        # case b)
        if self.fHasField(cookieField):
            return self.handleCookieRequest()

        # case c)
        if self.fHasField(getCookieField):
            return self.handleGetCookieRequest()

    def answer(self):
        global g_fVerbose
        try:
            if g_fVerbose:
                print "--------------------------------------------------------------------------------"

            # check transaction id before anything else
            if self.fHasField(transactionIdField):
                self.outputField(transactionIdField, self.getFieldValue(transactionIdField))
            else:
                return self.finish()

            # protocolVersion and clientInfo must exist
            if not self.fHasField(protocolVersionField):
                self.error = iPediaServerError.malformedRequest
                return self.finish()

            if not self.fHasField(clientInfoField):
                self.error = iPediaServerError.malformedRequest
                return self.finish()

            if PROTOCOL_VERSION != self.getFieldValue(protocolVersionField):
                self.error = iPediaServerError.invalidProtocolVersion
                return self.finish()

            if not self.computeUserId():
                return self.finish()

            assert self.userId

            if self.fHasField(verifyRegCodeField) and not self.handleVerifyRegistrationCodeRequest():
                return self.finish()

            if self.fHasField(getRandomField) and not self.handleGetRandomRequest():
                return self.finish()

            if self.fHasField(getArticleField):
                if not self.fRegisteredUser:
                    if self.fOverUnregisteredLookupsLimit():
                        return self.finish()

                if not self.handleGetArticleRequest():
                    return self.finish()

            if self.fHasField(searchField) and not self.handleSearchRequest():
                return self.finish();

            if self.fHasField(getArticleCountField):
                self.outputField(articleCountField, str(self.factory.articleCount))

            if self.fHasField(getDatabaseTimeField):
                self.outputField(databaseTimeField, self.factory.dbTime)

        except Exception, ex:
            dumpException(ex)
            self.error=iPediaServerError.serverFailure
 
        self.finish()

    def lineReceived(self, request):
        try:
            # empty line marks end of request
            if request == "":
                return self.answer()

            if self.error:
                return self.answer()

            if g_fVerbose:
                print request

            (field,value) = parseRequestLine(request)
            if None == field:
                self.error = iPediaServerError.malformedRequest
                return self.answer()

            if not validClientFields.has_key(field):
                self.error = iPediaServerError.invalidRequest
                return self.answer()                

            fHasArguments = validClientFields[field]
            if fHasArguments:
                if None == value:
                    # expected arguments for this request, but didn't get it
                    self.error = iPediaServerError.requestArgumentMissing
                    return self.answer()
            else:
                if None != value:
                    # got arguments even though the function doesn't expect it
                    self.error = iPediaServerError.unexpectedRequestArgument
                    return self.answer()

            if self.fHasField(field):
                # duplicate field
                self.error = iPediaServerError.malformedRequest
                return self.answer()

            self.setFieldValue(field,value)

        except Exception, ex:
            dumpException(ex)
            self.error=iPediaServerError.serverFailure
            self.answer()

class iPediaFactory(protocol.ServerFactory):

    def createArticlesConnection(self):
        #print "creating articles connection"
        return MySQLdb.Connect(host=iPediaDatabase.DB_HOST, user=iPediaDatabase.DB_USER, passwd=iPediaDatabase.DB_PWD, db=self.dbName)

    def createManagementConnection(self):
        #print "creating management connection"
        return MySQLdb.Connect(host=iPediaDatabase.DB_HOST, user=iPediaDatabase.DB_USER, passwd=iPediaDatabase.DB_PWD, db=iPediaDatabase.MANAGEMENT_DB)

    def __init__(self, dbName):
        self.changeDatabase(dbName)

    def changeDatabase(self, dbName):
        print "Switching to database %s" % dbName
        self.dbName=dbName
        self.dbTime = dbName[7:]
        db=self.createArticlesConnection()
        cursor=db.cursor()
        cursor.execute("""SELECT COUNT(*), min(id), max(id) FROM articles""")
        row=cursor.fetchone()
        self.articleCount=row[0]
        self.minDefinitionId=row[1]
        self.maxDefinitionId=row[2]
        cursor.execute("""SELECT COUNT(*) FROM redirects""")
        row=cursor.fetchone()
        self.redirectsCount=row[0]
        print "Number of Wikipedia articles: ", self.articleCount
        print "Number of redirects: ", self.redirectsCount
        cursor.close()
        db.close()

    protocol = iPediaProtocol

ipediaRe = re.compile("ipedia_[0-9]{8}", re.I)
def fIpediaDb(dbName):
    """Return True if a given database name is a name of the database with Wikipedia
    articles"""
    if ipediaRe.match(dbName):
        return True
    return False

# returns a dictionary describing all iPedia databases
# dictionary key is database name, the value is number of articles in that database
def getIpediaDbs():
    conn = MySQLdb.Connect(host=iPediaDatabase.DB_HOST, user=iPediaDatabase.DB_USER, passwd=iPediaDatabase.DB_PWD, db='')
    cur = conn.cursor()
    cur.execute("SHOW DATABASES;")
    dbsInfo = {}
    for row in cur.fetchall():
        dbName = row[0]
        if fIpediaDb(dbName):
            cur.execute("""SELECT COUNT(*) FROM %s.articles""" % dbName)
            row=cur.fetchone()
            articleCount=row[0]
            dbsInfo[dbName] = articleCount
    cur.close()
    conn.close()
    return dbsInfo

class iPediaTelnetProtocol(basic.LineReceiver):

    listRe=re.compile(r'\s*list\s*', re.I)
    useDbRe=re.compile(r'\s*use\s+(\w+)\s*', re.I)
    
    def __init__(self):
        self.delimiter='\n'
    
    def listDatabases(self):
        dbsInfo = None
        try:
            dbsInfo = getIpediaDbs()
            dbNames = dbsInfo.keys()
            dbNames.sort()
            for name in dbNames:
                articleCount = dbsInfo[name]
                self.transport.write( "%s (%d articles)\r\n" % (name,articleCount))
            self.transport.write("currently using: %s\r\n" % self.factory.iPediaFactory.dbName)
        except _mysql_exceptions.Error, ex:
            dumpException(ex)
            txt = arsutils.exceptionAsStr(ex)
            self.transport.write("exception: %s \r\n" % txt)

    def useDatabase(self, dbName):
        if dbName == self.factory.iPediaFactory.dbName:
            self.transport.write("already using %s database\r\n" % dbName)
            return
        self.transport.write("currently using: %s\r\n" % self.factory.iPediaFactory.dbName)
        dbsInfo = None
        try:
            dbsInfo = getIpediaDbs()
        except _mysql_exceptions.Error, ex:
            dumpException(ex)
            txt = arsutils.exceptionAsStr(ex)
            self.transport.write("exception: %s \r\n" % txt)
            return
        if not dbsInfo.has_key(dbName):
            self.transport.write("Database '%s' doesn't exist\r\n" % dbName)
            self.transport.write("Available databases:\r\n")
            dbNames = dbsInfo.keys()
            dbNames.sort()
            for name in dbNames:
                articleCount = dbsInfo[name]
                self.transport.write( "%s (%d articles)\r\n" % (name,articleCount))
            return
        articleCount = dbsInfo[dbName]
        # don't switch if articleCount is smaller than 100.000 - such a database
        # can't be good
        if articleCount < 100000:
            self.transport.write("Database '%s' doesn't have enough articles ('%d', at least 100.000 required)\r\n" % (dbName, articleCount))
            return
        self.factory.iPediaFactory.changeDatabase(dbName)
        self.transport.write("Switched to database '%s'\r\n" % dbName)

    def lineReceived(self, request):
        # print "telnet: '%s'" % request
        if iPediaTelnetProtocol.listRe.match(request):
            self.listDatabases()
            return

        match=iPediaTelnetProtocol.useDbRe.match(request)
        if match:
            self.useDatabase(match.group(1))
            return

        self.transport.loseConnection()
                
    
class iPediaTelnetFactory(protocol.ServerFactory):

    def __init__(self, otherFactory):
        self.iPediaFactory=otherFactory 
    
    protocol=iPediaTelnetProtocol

def usageAndExit():
    print "iPediaServer.py [-demon] [-silent] [-usepsyco] [-listdbs] [-db name]"
    sys.exit(0)        

def main():
    global g_fVerbose, g_fPsycoAvailable
    g_fVerbose=iPediaDatabase.g_fVerbose = True

    fDemon = arsutils.fDetectRemoveCmdFlag("-demon")
    if not fDemon:
        fDemon = arsutils.fDetectRemoveCmdFlag("-daemon")

    if arsutils.fDetectRemoveCmdFlag( "-silent" ):
        g_fVerbose, iPediaDatabase.g_fVerbose = False, False

    fUsePsyco = arsutils.fDetectRemoveCmdFlag("-usepsyco")
    if g_fPsycoAvailable and fUsePsyco:
        print "using psyco"
        psyco.full()

    dbsInfo = getIpediaDbs()
    dbNames = dbsInfo.keys()
    if 0==len(dbNames):
        print "No databases available"
        sys.exit(0)

    dbNames.sort()

    fListDbs = arsutils.fDetectRemoveCmdFlag("-listdbs")
    if fListDbs:
        for name in dbNames:
            print name
        sys.exit(0)

    dbName=arsutils.getRemoveCmdArg("-db")

    if len(sys.argv) != 1:
        usageAndExit()

    if dbName:
        if dbName in dbNames:
            print "Using database '%s'" % dbName
        else:
            print "Database '%s' doesn't exist" % dbName
            print "Available databases:"
            for name in dbNames:
                print "  %s" % name
            sys.exit(0)
    else: 
        dbName=dbNames[-1] # use the latest database
        print "Using database '%s'" % dbName

    if fDemon:
        arsutils.daemonize('/dev/null','/tmp/ipedia.log','/tmp/ipedia.log')

    factory=iPediaFactory(dbName)
    reactor.listenTCP(9000, factory)
    reactor.listenTCP(9001, iPediaTelnetFactory(factory))
    reactor.run()

if __name__ == "__main__":
    main()

