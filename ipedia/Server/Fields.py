# Copyright: Krzysztof Kowalczyk
# Owner: Krzysztof Kowalczyk

# This file contains a list of all fields used by ipedia protocol

# Protocol-Version is sent by a client with every request. It future-proofs our
# design (we can change the client-server protocol in newer versions but still
# support older clients using older protocols
# Value: a number representing a protocol version. By convetion we'll start at 1
#   and increase by 1 every time protocol changes
# Response: none
# Currently we only have one protocol of version 1.
protocolVersion =   "Protocol-Version"
# Client-Info is sent by a client with every request. It's purely informational
# field that enables us to track what kinds of clients/devices are used most.
# Value: version of the client e.g. "Palm 1.0", "Smartphone 0.5" etc.
# Response: none
clientInfo    =     "Client-Info"
# Transaction-ID is sent by the client and echoed by the server.
# Value: transaction id (arbitrary string)
# Client uses it to match server response with requests
# Response: Transaction-ID with the same value as sent by the client
transactionId =     "Transaction-ID"
# We use cookies to tie requests to a given client. Get-Cookie is sent by a
# client if it doesn't have a cookie assigned yet (which should only happen
# right after fresh install/re-install of the client).
# Value: (hopefully unique) device id in our encoded format
# Response: "Cookie" field with value being a string (cookie). 
getCookie =         "Get-Cookie"
# Client sends cookie assigned by the server so that we can tie requests to
# a given client (so that we can do stats). Cookie is generated by the server
# and sent as a result of Get-Cookie.
# Server checks if a cookie has been generated on the server and returns error
# invalidCookie if it wasn't or userDisabled if cookie is ok but user is
# marked as disabled
# Value: cookie
# Response: none
cookie =            "Cookie"
# Client uses Get-Article to request an article for a given title
# Value: term for which we want the article (e.g. "seattle")
# Response: (Article-Title, Article-Body, Format-Version) or Not-Found or Search-Results
getArticle =        "Get-Article"
# Client uses Get-Random-Article to get a random article
# Value: none
# Response: (Article-Title, Article-Body, Format-Version)
getRandom =         "Get-Random-Article"
# Sent by server along with Article-Body. Describes the format of Article-Body.
# Allows us to future-proof the design.
# Value: a number representing the format of article body. By convetion, starts
#   with 1 and will be increased by one every time we change the format.
#   Currently we only have one format (Format-Version is 1)
formatVersion =     "Format-Version"
# Sent by server in response to Get-Article, Get-Random-Article. It's the
# article body text.
# Value: size of article body followed by text of article itself.
articleBody =       "Article-Body"
# Sent by server in response to Get-Article, Get-Random-Article. It's the
# title of the article we're sending. Note: it might be different than title
# requested by Get-Article due to redirects.
# Value: title of the article
articleTitle =      "Article-Title"
# Server sends Reverse-Links along with Article-Body and Article-Title (as a
# response to Get-Article, Get-Random-Article). It's a '\n' separated list
# of article titles that link to a given article. The list is limited to 200
# - the limitation is implemented in the converter (without the limit we would
# send a lot of data (the biggest was around 100 kB) and more wouldn't be useful anyway.
# Value: payload, a '\n'-separated list of article titles that link to a given article.
reverseLinks =     "Reverse-Links"
# Retruned by the server in response to Get-Article, if the article hasn't been
# found.
notFound =          "Not-Found"
# Error is returned by the server if there was an error.
# Value: error number
error =             "Error"
# Client sends Registration-Code if registration code has been entered by the
# user and confirmed as valid by Register request.
# Value: registration code
# Server checks if a reg code is valid returns error invalidRegCode if it wasn't
# or userDisabled if reg code is ok but user is marked as disabled
# Response: none
regCode =           "Registration-Code"
search =            "Search"
searchResults =     "Search-Results"
# Client sends Get-Article-Count to retrieve the number of articles in the database.
# Value: none
# Server response: Article-Count
getArticleCount =   "Get-Article-Count"
# Server sends Article-Count as a response to Get-Article-Count
# Value: number of articles
articleCount =      "Article-Count"
# Client sends Get-Database-Time to get the time when the database was last synced
# Value: none
# Response: Database-Time
getDatabaseTime =   "Get-Database-Time"
# Server sends Database-Time in response to Get-Database-Time
# Value: date when database was synced, in the format YYYY-MM-DD
databaseTime =      "Database-Time"
# Client sends Verify-Registration-Code when it wants to check if a given
# registration code is valid.
# Value: registration code
# Response: Registration-Code-Valid
# Note: this is only to allow us to implement a good registration process on
# the client and doesn't influence our authentication mechanizm. Client sends
# this after user enters reg code on registration code. If server says "reg code
# valid" then client saves it in preferences and sends with all future requests.
# If server says "reg code invalid" then client ask the user to re-enter the code
# or forgets all about it.
# Risk: an attacker can sniff the protocol, figure out the purpose of this request
#   and use it to do a brute-force attack to discover reg codes. A way to fix
#   that would be to encrypt reg code with assymetric cryptography.
#   Cryptographic hash isn't enough because attacker can dissamble the code to
#   figure out the hash function used and do the hashing himself)
verifyRegCode =    "Verify-Registration-Code"
# Server sends Registration-Code-Valid in response to Verify-Registration-Code
# Value: 1 - reg code was valid, 0 - reg code was not valid
regCodeValid =     "Registration-Code-Valid"

# Below are multi-lingual (ml) versions of requests. They support wikipedias
# in multiple languages (and not only english, with which we started).
# They all provide the language (e.g. "en", "fr", "de") as the first parameter,
# then space and the rest is the same.
#
# We don't just re-define requests to have additional argument because of 
# backward-compatibility (new server will work just fine with old clients)
getArticleMl       = "Get-Article-Ml"
getRandomMl        = "Get-Random-Article-Ml"
searchMl           = "Search-Ml"
getArticleCountMl  = "Get-Article-Count-Ml"
getDatabaseTimeMl  = "Get-Database-Time-Ml"

# Client sends Get-Available-Langs to find out what are the languages we have
# wikipedia databases for on our server.
# Value: none
# Response: Available-Langs
getAvailableLangs = "Get-Available-Langs"

# Server sends Available-Langs in response Get-Available-Langs.
# Value: space-separated list of languages that a client can use in *-Ml
# requests as first parameter
availableLangs = "Available-Langs"

(fieldTypeClient, fieldTypeServer, fieldTypeBoth) = range(3)
(valueNone, valueInline, valuePayload) = range(3)

fieldsInfo = {
    protocolVersion : (fieldTypeClient, valueInline),
    clientInfo      : (fieldTypeClient, valueInline),
    transactionId   : (fieldTypeBoth,   valueInline),
    cookie          : (fieldTypeBoth,   valueInline),
    getCookie       : (fieldTypeClient, valueInline),
    formatVersion   : (fieldTypeServer, valueInline),
    articleBody     : (fieldTypeServer, valuePayload),
    articleTitle    : (fieldTypeServer, valueInline),
    reverseLinks    : (fieldTypeServer, valuePayload),
    notFound        : (fieldTypeServer, valueNone),
    error           : (fieldTypeServer, valueInline),
    regCode         : (fieldTypeBoth,   valueInline),
    searchResults   : (fieldTypeServer, valuePayload),
    articleCount    : (fieldTypeServer, valueInline),
    databaseTime    : (fieldTypeServer, valueInline),
    verifyRegCode   : (fieldTypeClient, valueInline),
    regCodeValid    : (fieldTypeServer, valueInline)

    getArticle      : (fieldTypeClient, valueInline),
    getRandom       : (fieldTypeClient, valueNone),
    search          : (fieldTypeClient, valueInline),
    getDatabaseTime : (fieldTypeClient, valueNone),
    getArticleCount : (fieldTypeClient, valueNone),

    getArticleMl      : (fieldTypeClient, valueInline),
    getRandomMl       : (fieldTypeClient, valueInline),
    searchMl          : (fieldTypeClient, valueInline),
    getDatabaseTimeMl : (fieldTypeClient, valueInline),
    getArticleCountMl : (fieldTypeClient, valueInline),

    getAvailableLangs : (fieldTypeClient, valueNone),
    availableLangs    : (fieldTypeServer, valueInline),
}

# return True if this is a valid field
def fValidField(fieldName):
    if fieldsInfo.has_key(fieldName):
        return True
    return False

# return True if a given field is a field sent by a client
def fClientField(fieldName):
    if not fValidField(fieldName):
        return False
    fieldType =  fieldsInfo[fieldName][0]
    if fieldTypeClient==fieldType or fieldTypeBoth==fieldType:
        return True
    return False

# return True if a given field is a field sent by a server
def fServerField(fieldName):
    if not fValidField(fieldName):
        return False
    fieldType = fieldsInfo[fieldName][0]
    if fieldTypeServer==fieldType or fieldTypeBoth==fieldType:
        return True
    return False

# return True if a given field is a payload field (i.e. its value is a payload)
def fPayloadField(fieldName):
    fieldValueType = fieldsInfo[fieldName][1]
    if valuePayload==fieldValueType:
        return True
    return False

def fFieldHasArguments(fieldName):
    fieldValueType = fieldsInfo[fieldName][1]
    if valueNone == fieldValueType:
        return False
    return True
